Allgemein:
um den server zum laufen zu kriegen, sind folgende schritte notwendig:

	zuerst auf der cmd
		npm install
	aufrufen, um die benötigten libraries über node zu installieren (ist vielleicht nicht notwendig, schadet aber nicht)
	
	dann ist noch ein mysql datenbankserver notwendig -> ich hab mal XAMPP verwendet, um den einfach zu starten (und über phpmyadmin zu verwalten)
		dort das script ultt.sql einfügen, um die tabelle zum testen zu machen
	
	danach kann der server eigentlich gestartet werden, mit (ins \server verzeichnis wechseln)
		node server.ts
		(nicht vergessen, apache zu beenden, server hört nämlich auf port 80)
			(oder natürlich den port verändern)
			
	bei navigation zu localhost wird die index.html seite zurückgegeben, welche einen kleinen db-test darstellt
		es können mit submit die daten in die db gespeichert werden,
		und mit refresh alle rows aus der db-tabelle gefetcht werden
		ziel des unity-prototypen soll es nun sein, auch diese funktionalität bereitzustellen
		
Update:
die routen des servers wurden nun zusammengekürzt, wie folgt:
	die default route '/' liefert nun das unity.html file zurück, welches die webplayer-unity datei nachlädt
	unity soll auf '/unity/db' WWWForm Daten post-en, um mit der Datenbank zu kommunizieren (siehe weiter unten)
die restlichen routen wurden entfernt

logging wird über das logging-module ./logging/logging.ts abgehandelt, welches dann über .log(logLevel, logMessage) aufgerufen wird (siehe code für beispiele)

db kommunikation läuft wie folgt ab:
	jegliche db kommunikation ist als schicken einer WWWForm mit passenden daten konzipiert.
	für ein schreiben zur datenbank sind folgende form-felder nötig:
		purpose = "post"
		table 	= "tableX" (die table, in die geschrieben werden soll)
		field1 	= "value1"
		..
		fieldn	= "valuen" (die felder in der reihenfolge der datenbank-spalten mit den zu schreibenden werten)
		
	für ein fetching aus der db sind folgende form-felder nötig:
		purpose = "get"
		table 	= "tableX" (die table, von welcher gefetcht werden soll)
		field1	= "value1"
		..
		fieldk	= "valuek" (k felder mit values, auf welche in der table gematched werden soll)
		field n	= "null"
		..
		field m	= "null" (o felder mit value "null", welche gefetcht werden sollen, und in dieser reihenfolge returned werden)
	die lösung mit den "null" werten ist nicht optimal (sie verhindert zB, dass "null" ein zulässiger wert eines feldes ist), aber die einfachste lösung, die mir eingefallen ist
	
	update ist zur zeit noch nicht implementiert
	
	siehe unity .cs datei für beispielhafte db kommunikation
	
zum login:
	als login soll ein post auf '/login' geschickt werden, mit folgenden daten:
		username = "theUserName"
		password = "thePassword"
	als response kommt dann ein
		"success" für erfolgreiches Einloggen
		"failure" fur nicht erfolgreiches Einloggen
	beispielhafte Rückmeldung an den User könnte dann sein: "username or password was incorrect"
	bitte zum testen einen test-user mit password anlegen
	das password ist nun noch plain gespeichert, im nächsten Sprint möcht ich das angehen und hashen+salten mitnehmen